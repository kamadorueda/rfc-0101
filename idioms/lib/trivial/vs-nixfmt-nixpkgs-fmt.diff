diff --git a/idioms/lib/trivial/after-nixfmt.nix b/idioms/lib/trivial/after-nixpkgs-fmt.nix
index 50127d5..8949964 100644
--- a/idioms/lib/trivial/after-nixfmt.nix
+++ b/idioms/lib/trivial/after-nixpkgs-fmt.nix
@@ -11,8 +11,7 @@ rec {
   */
   id =
     # The value to return
-    x:
-    x;
+    x: x;
 
   /* The constant function
 
@@ -28,8 +27,7 @@ rec {
     # Value to return
     x:
     # Value to ignore
-    y:
-    x;
+    y: x;
 
   /* Pipes a value through a list of functions, left to right.
 
@@ -81,25 +79,28 @@ rec {
   */
   concat = x: y: x ++ y;
 
-  # boolean ‚Äúor‚Äù
+  /* boolean ‚Äúor‚Äù */
   or = x: y: x || y;
 
-  # boolean ‚Äúand‚Äù
+  /* boolean ‚Äúand‚Äù */
   and = x: y: x && y;
 
-  # bitwise ‚Äúand‚Äù
-  bitAnd = builtins.bitAnd or (import ./zip-int-bits.nix
+  /* bitwise ‚Äúand‚Äù */
+  bitAnd = builtins.bitAnd
+    or (import ./zip-int-bits.nix
     (a: b: if a == 1 && b == 1 then 1 else 0));
 
-  # bitwise ‚Äúor‚Äù
-  bitOr = builtins.bitOr or (import ./zip-int-bits.nix
+  /* bitwise ‚Äúor‚Äù */
+  bitOr = builtins.bitOr
+    or (import ./zip-int-bits.nix
     (a: b: if a == 1 || b == 1 then 1 else 0));
 
-  # bitwise ‚Äúxor‚Äù
-  bitXor = builtins.bitXor or (import ./zip-int-bits.nix
+  /* bitwise ‚Äúxor‚Äù */
+  bitXor = builtins.bitXor
+    or (import ./zip-int-bits.nix
     (a: b: if a != b then 1 else 0));
 
-  # bitwise ‚Äúnot‚Äù
+  /* bitwise ‚Äúnot‚Äù */
   bitNot = builtins.sub (-1);
 
   /* Convert a boolean to a string.
@@ -124,8 +125,7 @@ rec {
     # Left attribute set
     x:
     # Right attribute set (higher precedence for equal keys)
-    y:
-    x // y;
+    y: x // y;
 
   /* Flip the order of the arguments of a binary function.
 
@@ -149,20 +149,21 @@ rec {
     # Function to call
     f:
     # Argument to check for null before passing it to `f`
-    a:
-    if a == null then a else f a;
+    a: if a == null then a else f a;
 
   # Pull in some builtins not included elsewhere.
   inherit (builtins)
-    pathExists readFile isBool isInt isFloat add sub lessThan seq deepSeq
-    genericClosure;
+    pathExists readFile isBool
+    isInt isFloat add sub lessThan
+    seq deepSeq genericClosure;
+
 
   ## nixpkgs version strings
 
-  # Returns the current full nixpkgs version number.
+  /* Returns the current full nixpkgs version number. */
   version = release + versionSuffix;
 
-  # Returns the current nixpkgs release number as string.
+  /* Returns the current nixpkgs release number as string. */
   release = lib.strings.fileContents ../.version;
 
   /* Returns the current nixpkgs release code name.
@@ -172,12 +173,12 @@ rec {
   */
   codeName = "Quokka";
 
-  # Returns the current nixpkgs version suffix as string.
-  versionSuffix = let suffixFile = ../.version-suffix;
-  in if pathExists suffixFile then
-    lib.strings.fileContents suffixFile
-  else
-    "pre-git";
+  /* Returns the current nixpkgs version suffix as string. */
+  versionSuffix =
+    let suffixFile = ../.version-suffix;
+    in if pathExists suffixFile
+    then lib.strings.fileContents suffixFile
+    else "pre-git";
 
   /* Attempts to return the the current revision of nixpkgs and
      returns the supplied default value otherwise.
@@ -190,15 +191,13 @@ rec {
     let
       revisionFile = "${toString ./..}/.git-revision";
       gitRepo = "${toString ./..}/.git";
-    in if lib.pathIsGitRepo gitRepo then
-      lib.commitIdFromGitRepo gitRepo
-    else if lib.pathExists revisionFile then
-      lib.fileContents revisionFile
-    else
-      default;
+    in
+    if lib.pathIsGitRepo gitRepo
+    then lib.commitIdFromGitRepo gitRepo
+    else if lib.pathExists revisionFile then lib.fileContents revisionFile
+    else default;
 
-  nixpkgsVersion = builtins.trace
-    "`lib.nixpkgsVersion` is deprecated, use `lib.version` instead!" version;
+  nixpkgsVersion = builtins.trace "`lib.nixpkgsVersion` is deprecated, use `lib.version` instead!" version;
 
   /* Determine whether the function is being called from inside a Nix
      shell.
@@ -207,12 +206,13 @@ rec {
   */
   inNixShell = builtins.getEnv "IN_NIX_SHELL" != "";
 
+
   ## Integer operations
 
-  # Return minimum of two numbers.
+  /* Return minimum of two numbers. */
   min = x: y: if x < y then x else y;
 
-  # Return maximum of two numbers.
+  /* Return maximum of two numbers. */
   max = x: y: if x > y then x else y;
 
   /* Integer modulus
@@ -225,6 +225,7 @@ rec {
   */
   mod = base: int: base - (int * (builtins.div base int));
 
+
   ## Comparisons
 
   /* C-style comparisons
@@ -233,7 +234,12 @@ rec {
      a == b, compare a b => 0
      a > b,  compare a b => 1
   */
-  compare = a: b: if a < b then -1 else if a > b then 1 else 0;
+  compare = a: b:
+    if a < b
+    then -1
+    else if a > b
+    then 1
+    else 0;
 
   /* Split type into two subtypes by predicate `p`, take all elements
      of the first subtype to be less than all the elements of the
@@ -264,19 +270,24 @@ rec {
     a:
     # Second value to compare
     b:
-    if p a then if p b then yes a b else -1 else if p b then 1 else no a b;
+    if p a
+    then if p b then yes a b else -1
+    else if p b then 1 else no a b;
+
 
   /* Reads a JSON file.
 
      Type :: path -> any
   */
-  importJSON = path: builtins.fromJSON (builtins.readFile path);
+  importJSON = path:
+    builtins.fromJSON (builtins.readFile path);
 
   /* Reads a TOML file.
 
      Type :: path -> any
   */
-  importTOML = path: builtins.fromTOML (builtins.readFile path);
+  importTOML = path:
+    builtins.fromTOML (builtins.readFile path);
 
   ## Warnings
 
@@ -293,46 +304,47 @@ rec {
   # TODO: figure out a clever way to integrate location information from
   # something like __unsafeGetAttrPos.
 
-  /* Print a warning before returning the second argument. This function behaves
-     like `builtins.trace`, but requires a string message and formats it as a
-     warning, including the `warning: ` prefix.
+  /*
+    Print a warning before returning the second argument. This function behaves
+    like `builtins.trace`, but requires a string message and formats it as a
+    warning, including the `warning: ` prefix.
 
-     To get a call stack trace and abort evaluation, set the environment variable
-     `NIX_ABORT_ON_WARN=true` and set the Nix options `--option pure-eval false --show-trace`
+    To get a call stack trace and abort evaluation, set the environment variable
+    `NIX_ABORT_ON_WARN=true` and set the Nix options `--option pure-eval false --show-trace`
 
-     Type: string -> a -> a
+    Type: string -> a -> a
   */
   warn =
-    if lib.elem (builtins.getEnv "NIX_ABORT_ON_WARN") [ "1" "true" "yes" ] then
-      msg:
-      builtins.trace "[1;31mwarning: ${msg}[0m" (abort
-        "NIX_ABORT_ON_WARN=true; warnings are treated as unrecoverable errors.")
-    else
-      msg: builtins.trace "[1;31mwarning: ${msg}[0m";
+    if lib.elem (builtins.getEnv "NIX_ABORT_ON_WARN") [ "1" "true" "yes" ]
+    then msg: builtins.trace "[1;31mwarning: ${msg}[0m" (abort "NIX_ABORT_ON_WARN=true; warnings are treated as unrecoverable errors.")
+    else msg: builtins.trace "[1;31mwarning: ${msg}[0m";
 
-  /* Like warn, but only warn when the first argument is `true`.
+  /*
+    Like warn, but only warn when the first argument is `true`.
 
-     Type: bool -> string -> a -> a
+    Type: bool -> string -> a -> a
   */
   warnIf = cond: msg: if cond then warn msg else id;
 
-  /* Like the `assert b; e` expression, but with a custom error message and
-     without the semicolon.
+  /*
+    Like the `assert b; e` expression, but with a custom error message and
+    without the semicolon.
 
-     If true, return the identity function, `r: r`.
+    If true, return the identity function, `r: r`.
 
-     If false, throw the error message.
+    If false, throw the error message.
 
-     Calls can be juxtaposed using function application, as `(r: r) a = a`, so
-     `(r: r) (r: r) a = a`, and so forth.
+    Calls can be juxtaposed using function application, as `(r: r) a = a`, so
+    `(r: r) (r: r) a = a`, and so forth.
 
-     Type: bool -> string -> a -> a
+    Type: bool -> string -> a -> a
 
-     Example:
+    Example:
+
+        throwIfNot (lib.isList overlays) "The overlays argument to nixpkgs must be a list."
+        lib.foldr (x: throwIfNot (lib.isFunction x) "All overlays passed to nixpkgs must be functions.") (r: r) overlays
+        pkgs
 
-         throwIfNot (lib.isList overlays) "The overlays argument to nixpkgs must be a list."
-         lib.foldr (x: throwIfNot (lib.isFunction x) "All overlays passed to nixpkgs must be functions.") (r: r) overlays
-         pkgs
   */
   throwIfNot = cond: msg: if cond then x: x else throw msg;
 
@@ -347,12 +359,11 @@ rec {
      Type: String -> List ComparableVal -> List ComparableVal -> a -> a
   */
   checkListOfEnum = msg: valid: given:
-    let unexpected = lib.subtractLists valid given;
-    in lib.throwIfNot (unexpected == [ ]) "${msg}: ${
-      builtins.concatStringsSep ", " (builtins.map builtins.toString unexpected)
-    } unexpected; valid ones: ${
-      builtins.concatStringsSep ", " (builtins.map builtins.toString valid)
-    }";
+    let
+      unexpected = lib.subtractLists valid given;
+    in
+    lib.throwIfNot (unexpected == [ ])
+      "${msg}: ${builtins.concatStringsSep ", " (builtins.map builtins.toString unexpected)} unexpected; valid ones: ${builtins.concatStringsSep ", " (builtins.map builtins.toString valid)}";
 
   info = msg: builtins.trace "INFO: ${msg}";
 
@@ -370,8 +381,9 @@ rec {
      function of the { a, b ? foo, ... }: format, but some facilities
      like callPackage expect to be able to query expected arguments.
   */
-  setFunctionArgs =
-    f: args: { # TODO: Should we add call-time "type" checking like built in?
+  setFunctionArgs = f: args:
+    {
+      # TODO: Should we add call-time "type" checking like built in?
       __functor = self: f;
       __functionArgs = args;
     };
@@ -383,16 +395,15 @@ rec {
      setFunctionArgs : (a ‚Üí b) ‚Üí Map String Bool.
   */
   functionArgs = f:
-    if f ? __functor then
-      f.__functionArgs or (lib.functionArgs (f.__functor f))
-    else
-      builtins.functionArgs f;
+    if f ? __functor
+    then f.__functionArgs or (lib.functionArgs (f.__functor f))
+    else builtins.functionArgs f;
 
   /* Check whether something is a function or something
      annotated with function args.
   */
-  isFunction = f:
-    builtins.isFunction f || (f ? __functor && isFunction (f.__functor f));
+  isFunction = f: builtins.isFunction f ||
+    (f ? __functor && isFunction (f.__functor f));
 
   /* Convert the given positive integer to a string of its hexadecimal
      representation. For example:
@@ -406,8 +417,8 @@ rec {
   toHexString = i:
     let
       toHexDigit = d:
-        if d < 10 then
-          toString d
+        if d < 10
+        then toString d
         else
           {
             "10" = "A";
@@ -417,7 +428,8 @@ rec {
             "14" = "E";
             "15" = "F";
           }.${toString d};
-    in lib.concatMapStrings toHexDigit (toBaseDigits 16 i);
+    in
+    lib.concatMapStrings toHexDigit (toBaseDigits 16 i);
 
   /* `toBaseDigits base i` converts the positive integer i to a list of its
      digits in the given base. For example:
@@ -431,12 +443,16 @@ rec {
   toBaseDigits = base: i:
     let
       go = i:
-        if i < base then
-          [ i ]
+        if i < base
+        then [ i ]
         else
           let
             r = i - ((i / base) * base);
             q = (i - r) / base;
-          in [ r ] ++ go q;
-    in assert (base >= 2); assert (i >= 0); lib.reverseList (go i);
+          in
+          [ r ] ++ go q;
+    in
+    assert (base >= 2);
+    assert (i >= 0);
+    lib.reverseList (go i);
 }
