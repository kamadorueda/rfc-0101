diff --git a/idioms/nixos/kernel/after-nixpkgs-fmt.nix b/idioms/nixos/kernel/after-alejandra.nix
index 440dd75..ae087c2 100644
--- a/idioms/nixos/kernel/after-nixpkgs-fmt.nix
+++ b/idioms/nixos/kernel/after-alejandra.nix
@@ -1,28 +1,25 @@
-{ config, lib, pkgs, ... }:
-
-with lib;
-
-let
-
+{
+  config,
+  lib,
+  pkgs,
+  ...
+}:
+with lib; let
   inherit (config.boot) kernelPatches;
   inherit (config.boot.kernel) features randstructSeed;
   inherit (config.boot.kernelPackages) kernel;
 
-  kernelModulesConf = pkgs.writeText "nixos.conf"
+  kernelModulesConf =
+    pkgs.writeText "nixos.conf"
     ''
       ${concatStringsSep "\n" config.boot.kernelModules}
     '';
-
-in
-
-{
-
+in {
   ###### interface
 
   options = {
-
     boot.kernel.features = mkOption {
-      default = { };
+      default = {};
       example = literalExpression "{ debug = true; }";
       internal = true;
       description = ''
@@ -36,14 +33,15 @@ in
 
     boot.kernelPackages = mkOption {
       default = pkgs.linuxPackages;
-      type = types.unspecified // { merge = mergeEqualOption; };
-      apply = kernelPackages: kernelPackages.extend (self: super: {
-        kernel = super.kernel.override (originalArgs: {
-          inherit randstructSeed;
-          kernelPatches = (originalArgs.kernelPatches or [ ]) ++ kernelPatches;
-          features = lib.recursiveUpdate super.kernel.features features;
+      type = types.unspecified // {merge = mergeEqualOption;};
+      apply = kernelPackages:
+        kernelPackages.extend (self: super: {
+          kernel = super.kernel.override (originalArgs: {
+            inherit randstructSeed;
+            kernelPatches = (originalArgs.kernelPatches or []) ++ kernelPatches;
+            features = lib.recursiveUpdate super.kernel.features features;
+          });
         });
-      });
       # We don't want to evaluate all of linuxPackages for the manual
       # - some of it might not even evaluate correctly.
       defaultText = literalExpression "pkgs.linuxPackages";
@@ -64,7 +62,7 @@ in
 
     boot.kernelPatches = mkOption {
       type = types.listOf types.attrs;
-      default = [ ];
+      default = [];
       example = literalExpression "[ pkgs.kernelPatches.ubuntu_fan_4_4 ]";
       description = "A list of additional patches to apply to the kernel.";
     };
@@ -83,11 +81,12 @@ in
     };
 
     boot.kernelParams = mkOption {
-      type = types.listOf (types.strMatching ''([^"[:space:]]|"[^"]*")+'' // {
-        name = "kernelParam";
-        description = "string, with spaces inside double quotes";
-      });
-      default = [ ];
+      type = types.listOf (types.strMatching ''([^"[:space:]]|"[^"]*")+''
+        // {
+          name = "kernelParam";
+          description = "string, with spaces inside double quotes";
+        });
+      default = [];
       description = "Parameters added to the kernel command line.";
     };
 
@@ -115,14 +114,14 @@ in
 
     boot.extraModulePackages = mkOption {
       type = types.listOf types.package;
-      default = [ ];
+      default = [];
       example = literalExpression "[ config.boot.kernelPackages.nvidia_x11 ]";
       description = "A list of additional packages supplying kernel modules.";
     };
 
     boot.kernelModules = mkOption {
       type = types.listOf types.str;
-      default = [ ];
+      default = [];
       description = ''
         The set of kernel modules to be loaded in the second stage of
         the boot process.  Note that modules that are needed to
@@ -134,8 +133,8 @@ in
 
     boot.initrd.availableKernelModules = mkOption {
       type = types.listOf types.str;
-      default = [ ];
-      example = [ "sata_nv" "ext3" ];
+      default = [];
+      example = ["sata_nv" "ext3"];
       description = ''
         The set of kernel modules in the initial ramdisk used during the
         boot process.  This set must include all modules necessary for
@@ -155,7 +154,7 @@ in
 
     boot.initrd.kernelModules = mkOption {
       type = types.listOf types.str;
-      default = [ ];
+      default = [];
       description = "List of modules that are always loaded by the initrd.";
     };
 
@@ -172,7 +171,7 @@ in
     system.modulesTree = mkOption {
       type = types.listOf types.path;
       internal = true;
-      default = [ ];
+      default = [];
       description = ''
         Tree of kernel modules.  This includes the kernel, plus modules
         built outside of the kernel.  Combine these into a single tree of
@@ -183,7 +182,7 @@ in
     };
 
     system.requiredKernelConfig = mkOption {
-      default = [ ];
+      default = [];
       example = literalExpression ''
         with config.lib.kernelConfig; [
           (isYes "MODULES")
@@ -199,17 +198,15 @@ in
         lib.kernelConfig functions to build list elements.
       '';
     };
-
   };
 
-
   ###### implementation
 
-  config = mkMerge
+  config =
+    mkMerge
     [
       (mkIf config.boot.initrd.enable {
-        boot.initrd.availableKernelModules =
-          optionals config.boot.initrd.includeDefaultModules ([
+        boot.initrd.availableKernelModules = optionals config.boot.initrd.includeDefaultModules ([
             # Note: most of these (especially the SATA/PATA modules)
             # shouldn't be included by default since nixos-generate-config
             # detects them, but I'm keeping them for now for backwards
@@ -248,8 +245,8 @@ in
             "hid_logitech_hidpp"
             "hid_logitech_dj"
             "hid_microsoft"
-
-          ] ++ optionals pkgs.stdenv.hostPlatform.isx86 [
+          ]
+          ++ optionals pkgs.stdenv.hostPlatform.isx86 [
             # Misc. x86 keyboard stuff.
             "pcips2"
             "atkbd"
@@ -259,51 +256,47 @@ in
             "rtc_cmos"
           ]);
 
-        boot.initrd.kernelModules =
-          optionals config.boot.initrd.includeDefaultModules [
-            # For LVM.
-            "dm_mod"
-          ];
+        boot.initrd.kernelModules = optionals config.boot.initrd.includeDefaultModules [
+          # For LVM.
+          "dm_mod"
+        ];
       })
 
       (mkIf (!config.boot.isContainer) {
-        system.build = { inherit kernel; };
+        system.build = {inherit kernel;};
 
-        system.modulesTree = [ kernel ] ++ config.boot.extraModulePackages;
+        system.modulesTree = [kernel] ++ config.boot.extraModulePackages;
 
         # Implement consoleLogLevel both in early boot and using sysctl
         # (so you don't need to reboot to have changes take effect).
         boot.kernelParams =
-          [ "loglevel=${toString config.boot.consoleLogLevel}" ] ++
-          optionals config.boot.vesa [ "vga=0x317" "nomodeset" ];
+          ["loglevel=${toString config.boot.consoleLogLevel}"]
+          ++ optionals config.boot.vesa ["vga=0x317" "nomodeset"];
 
         boot.kernel.sysctl."kernel.printk" = mkDefault config.boot.consoleLogLevel;
 
-        boot.kernelModules = [ "loop" "atkbd" ];
+        boot.kernelModules = ["loop" "atkbd"];
 
         # The Linux kernel >= 2.6.27 provides firmware.
-        hardware.firmware = [ kernel ];
+        hardware.firmware = [kernel];
 
         # Create /etc/modules-load.d/nixos.conf, which is read by
         # systemd-modules-load.service to load required kernel modules.
-        environment.etc =
-          {
-            "modules-load.d/nixos.conf".source = kernelModulesConf;
-          };
+        environment.etc = {
+          "modules-load.d/nixos.conf".source = kernelModulesConf;
+        };
 
-        systemd.services.systemd-modules-load =
-          {
-            wantedBy = [ "multi-user.target" ];
-            restartTriggers = [ kernelModulesConf ];
-            serviceConfig =
-              {
-                # Ignore failed module loads.  Typically some of the
-                # modules in ‘boot.kernelModules’ are "nice to have but
-                # not required" (e.g. acpi-cpufreq), so we don't want to
-                # barf on those.
-                SuccessExitStatus = "0 1";
-              };
+        systemd.services.systemd-modules-load = {
+          wantedBy = ["multi-user.target"];
+          restartTriggers = [kernelModulesConf];
+          serviceConfig = {
+            # Ignore failed module loads.  Typically some of the
+            # modules in ‘boot.kernelModules’ are "nice to have but
+            # not required" (e.g. acpi-cpufreq), so we don't want to
+            # barf on those.
+            SuccessExitStatus = "0 1";
           };
+        };
 
         lib.kernelConfig = {
           isYes = option: {
@@ -346,18 +339,23 @@ in
             # !!! Should this really be needed?
             (isYes "MODULES")
             (isYes "BINFMT_ELF")
-          ] ++ (optional (randstructSeed != "") (isYes "GCC_PLUGIN_RANDSTRUCT"));
+          ]
+          ++ (optional (randstructSeed != "") (isYes "GCC_PLUGIN_RANDSTRUCT"));
 
         # nixpkgs kernels are assumed to have all required features
-        assertions = if config.boot.kernelPackages.kernel ? features then [ ] else
-        let cfg = config.boot.kernelPackages.kernel.config; in map
-          (attrs:
-            { assertion = attrs.assertion cfg; inherit (attrs) message; }
-          )
-          config.system.requiredKernelConfig;
-
+        assertions =
+          if config.boot.kernelPackages.kernel ? features
+          then []
+          else let
+            cfg = config.boot.kernelPackages.kernel.config;
+          in
+            map (
+              attrs: {
+                assertion = attrs.assertion cfg;
+                inherit (attrs) message;
+              }
+            )
+            config.system.requiredKernelConfig;
       })
-
     ];
-
 }
